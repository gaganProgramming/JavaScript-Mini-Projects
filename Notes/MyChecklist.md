# Understand data types (primitive & reference)

## **1Ô∏è‚É£ Primitive Data Types (Stored in Stack Memory)**

üìå **Immutable (Cannot be changed)**  
üìå **Stored directly in memory**  
üìå **Compared by value**

| Data Type         | Example                            | Description                                        |
| ----------------- | ---------------------------------- | -------------------------------------------------- |
| **Number**        | `let x = 10;`                      | Any numeric value (integers & decimals)            |
| **String**        | `let name = "Gagan";`              | Sequence of characters                             |
| **Boolean**       | `let isReady = true;`              | `true` or `false`                                  |
| **Null**          | `let x = null;`                    | Intentional absence of value                       |
| **Undefined**     | `let y;`                           | A variable that is declared but not assigned       |
| **Symbol (ES6)**  | `let sym = Symbol('id');`          | Unique and immutable identifier                    |
| **BigInt (ES11)** | `let big = 12345678901234567890n;` | For large numbers beyond `Number.MAX_SAFE_INTEGER` |

‚úÖ **Example:**

```js
let a = 10;
let b = a; // Copy by value
b = 20;
console.log(a); // 10 (remains unchanged)
console.log(b); // 20
```

‚û°Ô∏è Here, `a` and `b` hold **separate copies** of the value.

---

## **2Ô∏è‚É£ Reference Data Types (Stored in Heap Memory)**

üìå **Mutable (Can be changed)**  
üìå **Stored as a reference (memory address) in the stack**  
üìå **Compared by reference, not value**

| Data Type    | Example                        | Description                         |
| ------------ | ------------------------------ | ----------------------------------- |
| **Object**   | `let obj = { name: "Gagan" };` | Key-value pairs                     |
| **Array**    | `let arr = [1, 2, 3];`         | List of values                      |
| **Function** | `function greet() {}`          | Functions are objects in JavaScript |
| **Date**     | `let today = new Date();`      | Used to work with dates             |

‚úÖ **Example:**

```js
let obj1 = { name: "Gagan" };
let obj2 = obj1; // Copy by reference

obj2.name = "Suresh"; // Modifies original object

console.log(obj1.name); // "Suresh"
console.log(obj2.name); // "Suresh"
```

‚û°Ô∏è Both `obj1` and `obj2` **point to the same memory location**, so modifying one affects the other.

---

## **3Ô∏è‚É£ Differences: Primitive vs Reference Types**

| Feature        | Primitive         | Reference             |
| -------------- | ----------------- | --------------------- |
| **Stored in**  | Stack Memory      | Heap Memory           |
| **Mutability** | Immutable         | Mutable               |
| **Comparison** | Compared by value | Compared by reference |
| **Assignment** | Copies the value  | Copies the reference  |

‚úÖ **Example:**

```js
// Primitive (Different memory locations)
let x = 10;
let y = x;
y = 20;
console.log(x, y); // 10, 20 (Separate values)

// Reference (Same memory location)
let arr1 = [1, 2, 3];
let arr2 = arr1;
arr2.push(4);
console.log(arr1, arr2); // [1, 2, 3, 4], [1, 2, 3, 4]
```

---

## **4Ô∏è‚É£ Checking Data Types: typeof vs instanceof**

üîπ **`typeof`** ‚Üí Used for primitive types  
üîπ **`instanceof`** ‚Üí Used for reference types

‚úÖ **Example:**

```js
console.log(typeof 10); // "number"
console.log(typeof "hello"); // "string"
console.log(typeof {}); // "object"
console.log(typeof []); // "object" (Array is an object)
console.log(typeof null); // "object" (JavaScript bug!)
console.log(typeof function () {}); // "function"

console.log([] instanceof Array); // true
console.log({} instanceof Object); // true
console.log(function () {} instanceof Function); // true
```

---

## **5Ô∏è‚É£ Avoiding Reference Issues (Deep vs Shallow Copy)**

### **Shallow Copy (Copies Reference)**

```js
let obj1 = { a: 1, b: 2 };
let obj2 = obj1; // Reference copy
obj2.a = 10;
console.log(obj1.a); // 10 (Both changed!)
```

### **Deep Copy (Creates a New Object)**

```js
let obj1 = { a: 1, b: 2 };
let obj2 = JSON.parse(JSON.stringify(obj1)); // Deep copy
obj2.a = 10;
console.log(obj1.a); // 1 (Original remains unchanged)
```

---

## **üöÄ Active Learning Tasks**

‚úÖ **Predict output before running code**  
‚úÖ **Write examples for each data type**  
‚úÖ **Try making a deep copy using spread operator**  
‚úÖ **Solve this challenge:**

```js
let a = { value: 10 };
let b = a;
b.value = 20;
console.log(a.value); // ??? (Predict!)
```

---

Want more coding challenges? üî• Let me know! üöÄ

# <br/> <br/>

# Learn type coercion and == vs ===

**JavaScript Type Coercion & `==` vs `===`**
Type coercion is JavaScript‚Äôs way of automatically converting values from one data type to another. This can happen **implicitly (automatic)** or **explicitly (manual)**.

---

## **1Ô∏è‚É£ Type Coercion in JavaScript**

üìå **Implicit Coercion** ‚Üí JavaScript automatically converts data types.  
üìå **Explicit Coercion** ‚Üí The developer manually converts data types.

‚úÖ **Example (Implicit Coercion):**

```js
console.log("5" - 2); // 3  (String "5" converted to Number)
console.log("5" + 2); // "52"  (Number 2 converted to String)
console.log(5 * "2"); // 10  (String "2" converted to Number)
console.log(10 / "5"); // 2  (String "5" converted to Number)
console.log(true + 1); // 2  (true ‚Üí 1, so 1 + 1 = 2)
console.log(false + 1); // 1  (false ‚Üí 0, so 0 + 1 = 1)
```

---

## **2Ô∏è‚É£ Truthy & Falsy Values**

Some values are **implicitly converted** to `true` or `false` in boolean contexts.

### **Falsy Values (Convert to `false`)**

```
0, "", null, undefined, NaN, false
```

‚úÖ **Example:**

```js
console.log(Boolean(0)); // false
console.log(Boolean("")); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean(false)); // false
```

### **Truthy Values (Convert to `true`)**

Everything **except falsy values** is truthy.

‚úÖ **Example:**

```js
console.log(Boolean("hello")); // true
console.log(Boolean(123)); // true
console.log(Boolean([])); // true (Empty array is truthy)
console.log(Boolean({})); // true (Empty object is truthy)
console.log(Boolean("0")); // true ("0" is a non-empty string)
```

---

## **3Ô∏è‚É£ `==` vs `===` (Equality Comparison)**

| Operator | Description     | Type Conversion?                           |
| -------- | --------------- | ------------------------------------------ |
| `==`     | Loose Equality  | ‚úÖ Yes (performs type coercion)            |
| `===`    | Strict Equality | ‚ùå No (compares both **value** & **type**) |

‚úÖ **Example:**

```js
console.log(5 == "5"); // true  (String "5" converted to Number)
console.log(5 === "5"); // false (Different types: number vs string)

console.log(0 == false); // true  (false ‚Üí 0)
console.log(0 === false); // false (Different types: number vs boolean)

console.log(null == undefined); // true  (Both treated as absence of value)
console.log(null === undefined); // false (Different types)
```

---

## **4Ô∏è‚É£ Special Cases in Type Coercion**

‚úÖ **Case 1: `null` vs `undefined`**

```js
console.log(null == undefined); // true  (Both are loosely equal)
console.log(null === undefined); // false (Different types)
```

‚úÖ **Case 2: Comparing `NaN`**

```js
console.log(NaN == NaN); // false (NaN is never equal to anything, even itself!)
console.log(isNaN(NaN)); // true (Use isNaN to check for NaN)
```

‚úÖ **Case 3: Object to Primitive Conversion**

```js
console.log([1, 2] + [3, 4]); // "1,23,4" (Arrays converted to strings)
console.log({} + []); // "[object Object]" (Object converted to string)
```

---

## **5Ô∏è‚É£ Avoiding Type Coercion Issues**

‚úÖ **Always use `===` instead of `==`** to prevent unexpected type conversions.  
‚úÖ **Convert types explicitly** using:

```js
// String to Number
console.log(Number("123")); // 123

// Number to String
console.log(String(123)); // "123"

// Boolean Conversion
console.log(Boolean(0)); // false
console.log(Boolean(1)); // true
```

---

## **üöÄ Active Learning Tasks**

‚úÖ **Predict the output of these:**

```js
console.log([] == false); //true
console.log("0" == false); //true
console.log(null == 0); //false
console.log([] + []); // Blank
console.log([] + {}); // [object Object]
console.log({} + []); // [object Object]
```

# <br/> <br/>

# Master hoisting (var, let, const, functions)

## **üî• JavaScript Hoisting (var, let, const, functions) üî•**

Hoisting is **JavaScript's default behavior** of moving declarations to the **top of their scope** before execution.  
üöÄ **Understanding hoisting helps prevent unexpected bugs!**

---

## **1Ô∏è‚É£ What is Hoisting?**

‚úÖ **JavaScript moves function and variable declarations to the top of their scope** during the compile phase.  
‚úÖ **Only declarations are hoisted, not initializations.**

### **Example:**

```js
console.log(x); // ‚ùì What happens?
var x = 10;
console.log(x); // ‚úÖ 10
```

üîπ **Output:**

```
undefined
10
```

**Why?**  
üîπ JavaScript **hoists** `var x;` to the top, but the assignment `x = 10;` stays in place.

**Behind the Scenes:**

```js
var x; // Hoisted declaration
console.log(x); // undefined (x exists but is not assigned yet)
x = 10;
console.log(x); // 10
```

---

## **2Ô∏è‚É£ Hoisting with `var`, `let`, and `const`**

| Keyword | Hoisted? | Initialized with?  | Scope          |
| ------- | -------- | ------------------ | -------------- |
| `var`   | ‚úÖ Yes   | `undefined`        | Function Scope |
| `let`   | ‚úÖ Yes   | ‚ùå Not initialized | Block Scope    |
| `const` | ‚úÖ Yes   | ‚ùå Not initialized | Block Scope    |

‚úÖ **Example with `let` and `const`:**

```js
console.log(y); // ‚ùå ReferenceError!
let y = 5;
console.log(y);
```

üîπ **Why?**  
`let` and `const` **are hoisted**, but they are **not initialized**.  
This means **you cannot access them before declaration** ‚Üí **Temporal Dead Zone (TDZ)**.

---

## **3Ô∏è‚É£ Hoisting with Functions**

‚úÖ **Function Declarations are fully hoisted.**  
‚úÖ **Function Expressions & Arrow Functions are NOT hoisted.**

### **Function Declaration (Hoisted ‚úÖ)**

```js
hello(); // ‚úÖ Works!

function hello() {
  console.log("Hello, world!");
}
```

üîπ **JavaScript moves the entire function to the top.**

---

### **Function Expression (Not Hoisted ‚ùå)**

```js
greet(); // ‚ùå TypeError: greet is not a function

var greet = function () {
  console.log("Hi there!");
};
```

üîπ **Why?**  
üîπ `var greet` is **hoisted** as `undefined`, but the function assignment happens later.

---

### **Arrow Functions (Not Hoisted ‚ùå)**

```js
sayHi(); // ‚ùå ReferenceError: Cannot access 'sayHi' before initialization

let sayHi = () => console.log("Hi!");
```

üîπ Arrow functions behave like `let/const` and **cannot be used before declaration**.

---

## **4Ô∏è‚É£ Temporal Dead Zone (TDZ)**

‚úÖ **The period between hoisting and initialization is called the Temporal Dead Zone.**

### **Example:**

```js
console.log(a); // ‚ùå ReferenceError
let a = 10;
```

üîπ **Why?**  
`let a;` is hoisted but **not initialized**, so accessing it before declaration **causes an error**.

---

## **5Ô∏è‚É£ Summary of Hoisting**

| Feature          | `var`          | `let`  | `const` | Function Declaration     | Function Expression / Arrow |
| ---------------- | -------------- | ------ | ------- | ------------------------ | --------------------------- |
| **Hoisted?**     | ‚úÖ Yes         | ‚úÖ Yes | ‚úÖ Yes  | ‚úÖ Yes (Fully Hoisted)   | ‚ùå No                       |
| **Initialized?** | ‚úÖ `undefined` | ‚ùå No  | ‚ùå No   | ‚úÖ Yes (Function exists) | ‚ùå No                       |
| **Scope?**       | Function       | Block  | Block   | Function                 | Function / Block            |

---

## **üöÄ Active Learning Tasks**

‚úÖ **Predict the output before running these:**

```js
console.log(num); // undefined
var num = 20;

console.log(test); // reference error: not initialized
let test = "Hello";

foo(); // Foo is called
function foo() {
  console.log("Foo is called!");
}

bar(); // Ref error: bar is not initialized
const bar = () => console.log("Arrow function!");
```

üîπ Try debugging the errors and understand **why they happen!** üöÄ

# Learn scope (global, function, block)

**üî• JavaScript Scope (Global, Function, Block) üî•**  
Scope **determines where variables and functions are accessible** in your code.

‚úÖ JavaScript has **three types of scope:**  
1Ô∏è‚É£ **Global Scope**  
2Ô∏è‚É£ **Function Scope**  
3Ô∏è‚É£ **Block Scope**

---

## **1Ô∏è‚É£ Global Scope üåç**

üîπ **Variables declared outside functions** are in the **global scope**.  
üîπ **Accessible anywhere** in the script.  
üîπ Can be modified from anywhere (**can cause bugs**).

‚úÖ **Example:**

```js
var globalVar = "I am global";

function showGlobal() {
  console.log(globalVar); // ‚úÖ Accessible
}

showGlobal();
console.log(globalVar); // ‚úÖ Accessible
```

‚úÖ **Output:**

```
I am global
I am global
```

üí° **Caution:** Global variables **pollute the global namespace** and can be **overwritten easily**.

---

## **2Ô∏è‚É£ Function Scope üè†**

üîπ **Variables declared inside a function** are only accessible **inside that function**.  
üîπ **`var` is function-scoped** (not block-scoped).  
üîπ Cannot be accessed **outside** the function.

‚úÖ **Example:**

```js
function testScope() {
  var localVar = "I am inside a function";
  console.log(localVar); // ‚úÖ Accessible
}

testScope();
console.log(localVar); // ‚ùå ReferenceError (Not accessible outside)
```

‚úÖ **Output:**

```
I am inside a function
ReferenceError: localVar is not defined
```

---

## **3Ô∏è‚É£ Block Scope üî≤ (`let` & `const`)**

üîπ **A block `{}` defines a scope for `let` & `const`.**  
üîπ Variables inside `{}` cannot be accessed **outside the block**.  
üîπ `var` **is NOT block-scoped**, only `let` and `const` are.

‚úÖ **Example (Block Scope with `let` & `const`):**

```js
{
  let blockVar = "I exist only inside this block";
  console.log(blockVar); // ‚úÖ Accessible inside block
}

console.log(blockVar); // ‚ùå ReferenceError (Not accessible outside)
```

‚úÖ **Example (`var` is NOT block-scoped):**

```js
if (true) {
  var x = 100;
}

console.log(x); // ‚úÖ 100 (var is function-scoped, NOT block-scoped)
```

‚úÖ **Output:**

```
100
```

üí° **Use `let` & `const` to prevent unintended access outside the block.**

---

## **4Ô∏è‚É£ Nested Scope (Lexical Scope) üè°**

üîπ **Inner functions have access to outer functions‚Äô variables.**  
üîπ **Outer functions do NOT have access to inner function variables.**

‚úÖ **Example:**

```js
function outer() {
  let outerVar = "Outer";

  function inner() {
    let innerVar = "Inner";
    console.log(outerVar); // ‚úÖ Accessible
    console.log(innerVar); // ‚úÖ Accessible
  }

  inner();
  console.log(innerVar); // ‚ùå ReferenceError (Not accessible outside inner)
}

outer();
```

‚úÖ **Output:**

```
Outer
Inner
ReferenceError: innerVar is not defined
```

---

## **5Ô∏è‚É£ Function Scope vs Block Scope**

| Feature              | `var`  | `let`  | `const` |
| -------------------- | ------ | ------ | ------- |
| **Function Scoped?** | ‚úÖ Yes | ‚ùå No  | ‚ùå No   |
| **Block Scoped?**    | ‚ùå No  | ‚úÖ Yes | ‚úÖ Yes  |
| **Reassignable?**    | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No   |

---

## **üöÄ Active Learning Tasks**

‚úÖ **Predict the output before running these:**

```js
var globalVar = "Global";

function test() {
  var functionVar = "Function Scope";
  if (true) {
    let blockVar = "Block Scope";
    var functionVar2 = "Still Function Scope";
  }
  console.log(globalVar); // ???
  console.log(functionVar); // ???
  console.log(blockVar); // ???
  console.log(functionVar2); // ???
}

test();
console.log(globalVar); // ???
console.log(functionVar); // ???
```

üîπ Try debugging errors and understanding **why they happen!** üöÄ

# Understand closures with examples

**üî• JavaScript Closures üî•**

Closures are **one of the most powerful concepts in JavaScript**.

### **üîπ What is a Closure?**

A closure is **a function that remembers the variables from its outer function even after the outer function has finished executing**.

‚úÖ **A closure is created when:**  
1Ô∏è‚É£ A function is **inside another function** (nested function).  
2Ô∏è‚É£ The **inner function accesses variables from the outer function**.  
3Ô∏è‚É£ The outer function **returns** the inner function.

---

## **1Ô∏è‚É£ Basic Example of a Closure**

```js
function outerFunction() {
  let outerVar = "I am from outer";

  function innerFunction() {
    console.log(outerVar); // ‚úÖ Can access outerVar
  }

  return innerFunction;
}

const closureFunc = outerFunction(); // outerFunction runs and returns innerFunction
closureFunc(); // Still remembers outerVar even though outerFunction has finished
```

‚úÖ **Output:**

```
I am from outer
```

üîπ **Why does this work?**  
Even though `outerFunction` has finished executing, `innerFunction` **remembers** `outerVar` due to closure.

---

## **2Ô∏è‚É£ Closures with a Counter (Practical Use Case)**

Closures **help maintain private variables** in JavaScript.

```js
function createCounter() {
  let count = 0; // Private variable

  return function () {
    count++; // Modifies private variable
    console.log("Counter:", count);
  };
}

const counter = createCounter();
counter(); // Counter: 1
counter(); // Counter: 2
counter(); // Counter: 3
```

‚úÖ **Output:**

```
Counter: 1
Counter: 2
Counter: 3
```

üîπ **Why use closures here?**  
üîπ The `count` variable is **protected** and **cannot be accessed directly from outside**.

---

## **3Ô∏è‚É£ Closures with Parameters**

Closures can **remember function arguments**.

```js
function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const double = multiplier(2);
console.log(double(5)); // 10
console.log(double(10)); // 20

const triple = multiplier(3);
console.log(triple(5)); // 15
```

‚úÖ **Output:**

```
10
20
15
```

üîπ **How does this work?**

- `double` **remembers** `factor = 2`
- `triple` **remembers** `factor = 3`
- The inner function **multiplies the number with the remembered factor**.

---

## **4Ô∏è‚É£ Closures for Data Privacy (Avoid Global Variables)**

Closures **help protect data from being modified accidentally**.

```js
function bankAccount(initialBalance) {
  let balance = initialBalance; // Private variable

  return {
    deposit: function (amount) {
      balance += amount;
      console.log(`Deposited: ‚Çπ${amount}. New Balance: ‚Çπ${balance}`);
    },
    withdraw: function (amount) {
      if (amount > balance) {
        console.log("Insufficient funds!");
      } else {
        balance -= amount;
        console.log(`Withdrawn: ‚Çπ${amount}. New Balance: ‚Çπ${balance}`);
      }
    },
    checkBalance: function () {
      console.log(`Balance: ‚Çπ${balance}`);
    },
  };
}

const myAccount = bankAccount(1000);
myAccount.deposit(500); // Deposited: ‚Çπ500. New Balance: ‚Çπ1500
myAccount.withdraw(300); // Withdrawn: ‚Çπ300. New Balance: ‚Çπ1200
myAccount.checkBalance(); // Balance: ‚Çπ1200
```

‚úÖ **Output:**

```
Deposited: ‚Çπ500. New Balance: ‚Çπ1500
Withdrawn: ‚Çπ300. New Balance: ‚Çπ1200
Balance: ‚Çπ1200
```

üîπ **Why use closures?**  
üîπ `balance` is **private** and **cannot be accessed directly**.

```js
console.log(myAccount.balance); // ‚ùå Undefined! (Protected by closure)
```

---

## **5Ô∏è‚É£ Closures in `setTimeout` (Common Pitfall)**

Closures **capture the variable reference, not its value**.

```js
for (var i = 1; i <= 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```

‚úÖ **Expected Output (Wrong Behavior)**

```
4
4
4
```

‚ùå **Why does this happen?**

- `var i` is function-scoped, not block-scoped.
- The loop runs first, `i` becomes 4.
- By the time `setTimeout` runs, `i = 4`.

‚úÖ **Fix using `let` (Block Scope)**

```js
for (let i = 1; i <= 3; i++) {
  setTimeout(function () {
    console.log(i);
  }, i * 1000);
}
```

‚úÖ **Correct Output**

```
1
2
3
```

üí° **`let` creates a new scope for each iteration!** üöÄ

---

## **üöÄ Active Learning Tasks**

‚úÖ **Predict the output before running these:**

```js
function outer(x) {
  return function (y) {
    return x + y;
  };
}

const add5 = outer(5);
console.log(add5(10)); // ???
console.log(add5(20)); // ???

const add10 = outer(10);
console.log(add10(10)); // ???
```

```js
function secretMessage() {
  let message = "This is a secret!";
  return function () {
    console.log(message);
  };
}

const reveal = secretMessage();
reveal(); // ???
console.log(message); // ???
```

---

## **üî• Summary**

‚úî **Closures allow functions to "remember" variables from their outer scope.**  
‚úî **Useful for private variables, stateful functions, and avoiding global pollution.**  
‚úî **Common use cases: Counters, Data Privacy, Event Handlers, `setTimeout`.**

üöÄ **Master closures and level up your JavaScript skills!**

# Master this keyword and implicit/explicit binding

**üî• Mastering `this` Keyword & Binding in JavaScript üî•**

The `this` keyword in JavaScript **refers to the object that is executing the current function**.  
But **its value depends on how the function is called** (not where it is defined).

---

**üîπ 1Ô∏è‚É£ Understanding `this` in Different Contexts**

### **üîπ Global Context (Outside Any Function)**

```js
console.log(this);
```

‚úÖ In the **browser**, `this` refers to the `window` object.  
‚úÖ In **Node.js**, `this` is `{}` (an empty object in a module).

---

### **üîπ 2Ô∏è‚É£ `this` Inside a Function**

```js
function show() {
  console.log(this);
}

show();
```

‚úÖ **In non-strict mode (`this` is `window`)**  
‚úÖ **In strict mode (`this` is `undefined`)**

```js
"use strict";
function show() {
  console.log(this);
}
show(); // undefined
```

üí° **Why?** In strict mode, JavaScript prevents accidental global object modification.

---

### **üîπ 3Ô∏è‚É£ `this` Inside an Object Method**

When calling a function as an **object method**, `this` refers to the **object itself**.

```js
const obj = {
  name: "Gagan",
  greet: function () {
    console.log(`Hello, ${this.name}`);
  },
};

obj.greet(); // ‚úÖ Hello, Gagan
```

üí° **Why?** `this` refers to the `obj` because `greet()` is called as `obj.greet()`.

---

### **üîπ 4Ô∏è‚É£ `this` in Arrow Functions (`=>`)**

Arrow functions **do not have their own `this`**. They inherit `this` from their **enclosing scope**.

```js
const obj = {
  name: "Gagan",
  greet: () => {
    console.log(`Hello, ${this.name}`);
  },
};

obj.greet(); // ‚ùå Undefined (Arrow function takes `this` from global scope)
```

üí° **Fix: Use a normal function**

```js
const obj = {
  name: "Gagan",
  greet() {
    console.log(`Hello, ${this.name}`);
  },
};

obj.greet(); // ‚úÖ Hello, Gagan
```

---

**üîπ 5Ô∏è‚É£ The Four Types of `this` Binding**

### **üîπ (1) Default Binding (Global Scope)**

When calling a function normally, `this` refers to the **global object** (`window` in browsers).

```js
function show() {
  console.log(this);
}

show(); // ‚úÖ window (or `global` in Node.js)
```

---

### **üîπ (2) Implicit Binding (Object Method)**

If a function is called **inside an object**, `this` refers to **the object**.

```js
const user = {
  name: "Gagan",
  greet() {
    console.log(`Hello, ${this.name}`);
  },
};

user.greet(); // ‚úÖ "Hello, Gagan"
```

üí° **`this` refers to `user` because `greet()` is called on `user`**.

---

### **üîπ (3) Explicit Binding (`call`, `apply`, `bind`)**

You can **manually set `this`** using `call`, `apply`, or `bind`.

#### ‚úÖ **`call()`** - Calls function with an explicit `this`

```js
function greet() {
  console.log(`Hello, ${this.name}`);
}

const user = { name: "Gagan" };

greet.call(user); // ‚úÖ Hello, Gagan
```

#### ‚úÖ **`apply()`** - Same as `call()`, but takes arguments as an array

```js
function introduce(age, city) {
  console.log(
    `Hello, my name is ${this.name}, I am ${age} years old from ${city}.`
  );
}

const user = { name: "Gagan" };

introduce.apply(user, [25, "Bangalore"]);
// ‚úÖ Hello, my name is Gagan, I am 25 years old from Bangalore.
```

#### ‚úÖ **`bind()`** - Returns a new function with a fixed `this`

```js
const person = { name: "Gagan" };

function greet() {
  console.log(`Hello, ${this.name}`);
}

const greetGagan = greet.bind(person);
greetGagan(); // ‚úÖ Hello, Gagan
```

üí° **`bind()` does not call the function immediately**‚Äîit returns a new function with `this` bound.

---

### **üîπ (4) `this` in Constructor Functions**

When using `new`, `this` refers to **the new object being created**.

```js
function User(name) {
  this.name = name;
}

const user1 = new User("Gagan");
console.log(user1.name); // ‚úÖ Gagan
```

---

**üöÄ Active Learning Tasks**
‚úÖ **Predict the output before running these:**

```js
const obj = {
  name: "Gagan",
  print: function () {
    setTimeout(function () {
      console.log(this.name);
    }, 1000);
  },
};

obj.print(); // ???
```

üí° **Fix using arrow function:**

```js
const obj = {
  name: "Gagan",
  print: function () {
    setTimeout(() => {
      console.log(this.name);
    }, 1000);
  },
};

obj.print(); // ‚úÖ Gagan
```

‚úÖ **Try using `call`, `apply`, and `bind` to change `this`.**

---

## **üî• Summary**

| üî• **Binding Type**  | üî• **How `this` is determined**                          |
| -------------------- | -------------------------------------------------------- |
| **Default Binding**  | Global object (`window` in browser, `global` in Node.js) |
| **Implicit Binding** | `this` refers to the object calling the function         |
| **Explicit Binding** | `call()`, `apply()`, `bind()` manually set `this`        |
| **New Binding**      | `this` refers to the newly created object in constructor |

üöÄ **Master `this` and ace your JavaScript interviews!**

# Learn ES6+ features (let, const, template literals, arrow functions, spread/rest, destructuring, optional chaining)

**üî• ES6+ Features You Must Learn for JavaScript Interviews üî•**

ES6 (ECMAScript 2015) and later versions introduced powerful features that make JavaScript more readable, concise, and efficient. Below is a complete guide with examples for each major ES6+ feature.

---

## **üîπ 1Ô∏è‚É£ `let` and `const` (Block Scope & Immutable Variables)**

Before ES6, JavaScript only had `var`, which has **function scope** and is hoisted. ES6 introduced `let` and `const`, which have **block scope**.

### ‚úÖ **Using `let`**

```js
let age = 25;
age = 26; // ‚úÖ Allowed
console.log(age); // 26
```

- `let` **can** be reassigned but **cannot** be redeclared in the same scope.
- It has **block scope**, meaning it is only accessible within `{}`.

### ‚ùå **Using `var` (Avoid This)**

```js
if (true) {
  var x = 10;
}
console.log(x); // ‚úÖ 10 (var is function-scoped, not block-scoped)
```

### ‚úÖ **Using `const` (Immutable Variables)**

```js
const PI = 3.14;
PI = 3.1415; // ‚ùå Error: Assignment to constant variable
```

- `const` **must** be initialized during declaration.
- **Immutable reference**, but **mutable objects**:

```js
const user = { name: "Gagan" };
user.name = "Suresh"; // ‚úÖ Allowed (Object properties can change)
console.log(user); // { name: "Suresh" }
```

---

## **üîπ 2Ô∏è‚É£ Template Literals (Backticks `` ` ` `)**

Before ES6, string concatenation was messy:

```js
let name = "Gagan";
console.log("Hello, " + name + "! Welcome."); // ‚ùå Ugly syntax
```

### ‚úÖ **Using Template Literals**

```js
let name = "Gagan";
console.log(`Hello, ${name}! Welcome.`); // ‚úÖ Clean & readable
```

- Supports **multiline strings**:

```js
const message = `This is line 1
This is line 2`;
console.log(message);
```

---

## **üîπ 3Ô∏è‚É£ Arrow Functions (`=>`)**

Arrow functions provide a **shorter syntax** and **do not have their own `this`**.

### ‚úÖ **Example**

```js
const add = (a, b) => a + b;
console.log(add(5, 3)); // ‚úÖ 8
```

- Implicit `return` if **one-liner**.
- If **multiple lines**, use `{}`:

```js
const multiply = (a, b) => {
  console.log("Multiplying...");
  return a * b;
};
console.log(multiply(4, 2)); // ‚úÖ 8
```

üí° **Arrow functions do NOT have their own `this`**

```js
const user = {
  name: "Gagan",
  greet: function () {
    setTimeout(() => {
      console.log(`Hello, ${this.name}`); // ‚úÖ "Hello, Gagan"
    }, 1000);
  },
};
user.greet();
```

Here, `this` refers to `user` (lexical `this`), because arrow functions inherit `this` from the surrounding scope.

---

## **üîπ 4Ô∏è‚É£ Spread (`...`) and Rest (`...`) Operators**

The `...` operator is used in **two ways**:
1Ô∏è‚É£ **Spread Operator** ‚Äì Expands an array/object  
2Ô∏è‚É£ **Rest Operator** ‚Äì Collects arguments

### ‚úÖ **Using Spread (`...`)**

```js
const nums = [1, 2, 3];
const newNums = [...nums, 4, 5];
console.log(newNums); // ‚úÖ [1, 2, 3, 4, 5]
```

üí° **Works with Objects**

```js
const user = { name: "Gagan", age: 25 };
const updatedUser = { ...user, city: "Bangalore" };
console.log(updatedUser); // ‚úÖ { name: "Gagan", age: 25, city: "Bangalore" }
```

### ‚úÖ **Using Rest (`...`) in Functions**

```js
function sum(...numbers) {
  return numbers.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3, 4)); // ‚úÖ 10
```

---

## **üîπ 5Ô∏è‚É£ Destructuring (Extract Values Easily)**

Destructuring makes it easy to **extract values from objects/arrays**.

### ‚úÖ **Array Destructuring**

```js
const numbers = [10, 20, 30];
const [first, second] = numbers;
console.log(first, second); // ‚úÖ 10 20
```

### ‚úÖ **Object Destructuring**

```js
const person = { name: "Gagan", age: 25, city: "Bangalore" };
const { name, city } = person;
console.log(name, city); // ‚úÖ "Gagan Bangalore"
```

üí° **Renaming while destructuring**

```js
const { name: fullName, age } = person;
console.log(fullName); // ‚úÖ "Gagan"
```

---

## **üîπ 6Ô∏è‚É£ Optional Chaining (`?.`)**

Optional chaining (`?.`) prevents errors when accessing nested properties that may not exist.

### ‚úÖ **Without Optional Chaining**

```js
const user = { name: "Gagan", address: { city: "Bangalore" } };
console.log(user.address.city); // ‚úÖ "Bangalore"
console.log(user.contact.phone); // ‚ùå Error: Cannot read property 'phone'
```

### ‚úÖ **With Optional Chaining (`?.`)**

```js
console.log(user.contact?.phone); // ‚úÖ undefined (No Error)
```

üí° **Works with functions too**

```js
user.sayHello?.(); // ‚úÖ No Error, even if sayHello() is undefined
```

---

**üöÄ Active Learning Tasks**
‚úÖ **Rewrite the following using ES6 features:**

```js
var person = { name: "Gagan", age: 25 };
var city = person.city ? person.city : "Unknown";
console.log(person.name + " is " + person.age + " years old from " + city);
```

üí° **Solution (Using Destructuring & Template Literals)**

```js
const person = { name: "Gagan", age: 25 };
const { city = "Unknown" } = person;
console.log(`${person.name} is ${person.age} years old from ${city}`);
```

‚úÖ **Write an arrow function that takes multiple arguments using the rest operator.**  
‚úÖ **Use spread to copy and modify an array.**  
‚úÖ **Create an object and extract properties using destructuring.**

---

**üî• Summary Table**
| Feature | Description |
|---------|------------|
| **`let` & `const`** | `let` (block-scoped, reassignable), `const` (block-scoped, immutable) |
| **Template Literals** | Use backticks `` ` ` `` for cleaner string interpolation |
| **Arrow Functions (`=>`)** | Shorter function syntax, no own `this` |
| **Spread (`...`)** | Expands arrays/objects |
| **Rest (`...`)** | Gathers function arguments |
| **Destructuring** | Extracts values from arrays/objects |
| **Optional Chaining (`?.`)** | Prevents errors when accessing undefined properties |

üöÄ **Master these ES6+ features and ace your JavaScript interviews!**

# Understand higher-order functions (map, filter, reduce)

    **üî• Higher-Order Functions in JavaScript (map, filter, reduce) üî•**

Higher-order functions are functions that **take other functions as arguments** or **return functions**. In JavaScript, `map()`, `filter()`, and `reduce()` are the most commonly used higher-order functions for working with arrays.

---

## **üîπ 1Ô∏è‚É£ `map()` ‚Äì Transform Each Element**

The `map()` method creates a **new array** by applying a function to **each element** of the original array.

### ‚úÖ **Example: Convert Prices from INR to USD**

```js
const pricesInINR = [100, 200, 300];
const conversionRate = 0.012; // 1 INR = 0.012 USD

const pricesInUSD = pricesInINR.map((price) => price * conversionRate);
console.log(pricesInUSD); // ‚úÖ [1.2, 2.4, 3.6]
```

üí° **Key Points:**

- `map()` **returns a new array** (does not modify the original).
- It applies the function to **each** element in the array.

### ‚úÖ **Example: Convert an Array of Names to Uppercase**

```js
const names = ["gagan", "suresh", "developer"];
const upperNames = names.map((name) => name.toUpperCase());
console.log(upperNames); // ‚úÖ ["GAGAN", "SURESH", "DEVELOPER"]
```

---

## **üîπ 2Ô∏è‚É£ `filter()` ‚Äì Select Elements Based on a Condition**

The `filter()` method **returns a new array** containing elements that **pass a condition**.

### ‚úÖ **Example: Filter Out Even Numbers**

```js
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumbers = numbers.filter((num) => num % 2 === 0);
console.log(evenNumbers); // ‚úÖ [2, 4, 6]
```

### ‚úÖ **Example: Get Users Who Are Adults**

```js
const users = [
  { name: "Gagan", age: 25 },
  { name: "Ravi", age: 17 },
  { name: "Asha", age: 30 },
];

const adults = users.filter((user) => user.age >= 18);
console.log(adults);
// ‚úÖ [{ name: "Gagan", age: 25 }, { name: "Asha", age: 30 }]
```

üí° **Key Points:**

- `filter()` only **keeps** elements that **pass** the condition.
- It does **not** modify the original array.

---

## **üîπ 3Ô∏è‚É£ `reduce()` ‚Äì Combine All Elements into a Single Value**

The `reduce()` method **reduces an array** to a **single value** by applying a function **iteratively**.

### ‚úÖ **Example: Find the Sum of an Array**

```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // ‚úÖ 15
```

üí° **How `reduce()` Works Here:**

1. `acc = 0`, `num = 1` ‚Üí `acc = 0 + 1 = 1`
2. `acc = 1`, `num = 2` ‚Üí `acc = 1 + 2 = 3`
3. `acc = 3`, `num = 3` ‚Üí `acc = 3 + 3 = 6`
4. `acc = 6`, `num = 4` ‚Üí `acc = 6 + 4 = 10`
5. `acc = 10`, `num = 5` ‚Üí `acc = 10 + 5 = 15`

---

### ‚úÖ **Example: Find Maximum Value in an Array**

```js
const numbers = [10, 5, 8, 20, 3];

const maxNumber = numbers.reduce(
  (max, num) => (num > max ? num : max),
  numbers[0]
);

console.log(maxNumber); // ‚úÖ 20
```

üí° **How It Works:**

- The `max` variable stores the **largest value seen so far**.
- If `num` is greater than `max`, update `max`.

---

### ‚úÖ **Example: Count the Occurrences of Each Item**

```js
const words = ["apple", "banana", "apple", "orange", "banana", "apple"];

const wordCount = words.reduce((acc, word) => {
  acc[word] = (acc[word] || 0) + 1;
  return acc;
}, {});

console.log(wordCount);
// ‚úÖ { apple: 3, banana: 2, orange: 1 }
```

üí° **Key Points:**

- `reduce()` can be used to **group elements** in an array.
- The accumulator (`acc`) starts as `{}` (an empty object).

---

**üöÄ Active Learning Tasks**
‚úÖ **Rewrite the following using `map()`, `filter()`, or `reduce()`**

```js
const numbers = [1, 2, 3, 4, 5];
// Task 1: Double each number
// Task 2: Get numbers greater than 3
// Task 3: Calculate the total sum
```

‚úÖ **Create an array of student objects and use `filter()` to find those who scored above 75.**  
‚úÖ **Use `reduce()` to count the number of occurrences of words in an array.**  
‚úÖ **Find the longest word in an array using `reduce()`.**

---

**üî• Summary Table**
| Function | Purpose | Returns |
|----------|---------|---------|
| **`map()`** | Transforms each element | New array |
| **`filter()`** | Selects elements based on a condition | New array |
| **`reduce()`** | Reduces array to a single value | Single value |

üöÄ **Master these higher-order functions and ace your JavaScript interviews!**

# Learn DOM Manipulation

**üî• DOM Manipulation in JavaScript ‚Äì A Complete Guide üî•**

The **Document Object Model (DOM)** allows JavaScript to **interact with and modify HTML & CSS** dynamically. This is essential for building interactive web applications.

---

## **üöÄ 1Ô∏è‚É£ Selecting Elements**

To manipulate the DOM, you first need to **select** elements. There are multiple ways to do this:

### ‚úÖ **Using `getElementById` (Single Element)**

```js
const heading = document.getElementById("main-title");
console.log(heading); // Logs the element with id "main-title"
```

### ‚úÖ **Using `getElementsByClassName` (Multiple Elements, Live Collection)**

```js
const items = document.getElementsByClassName("list-item");
console.log(items); // HTMLCollection of elements with class "list-item"
```

### ‚úÖ **Using `getElementsByTagName` (Multiple Elements, Live Collection)**

```js
const paragraphs = document.getElementsByTagName("p");
console.log(paragraphs); // HTMLCollection of <p> elements
```

### ‚úÖ **Using `querySelector` (First Match)**

```js
const firstItem = document.querySelector(".list-item");
console.log(firstItem); // First element with class "list-item"
```

### ‚úÖ **Using `querySelectorAll` (All Matches, NodeList)**

```js
const allItems = document.querySelectorAll(".list-item");
console.log(allItems); // NodeList of elements with class "list-item"
```

üí° **Key Difference:**

- `getElementsByClassName` / `getElementsByTagName` return **live collections** (auto-update when DOM changes).
- `querySelectorAll` returns a **static NodeList** (does not auto-update).

---

## **üöÄ 2Ô∏è‚É£ Modifying Elements**

Once you select an element, you can modify its **text, HTML, attributes, or styles**.

### ‚úÖ **Change Text Content**

```js
const heading = document.getElementById("main-title");
heading.textContent = "JavaScript DOM Mastery!";
```

### ‚úÖ **Change Inner HTML**

```js
const content = document.querySelector("#content");
content.innerHTML = "<h2>New Content Added!</h2>";
```

### ‚úÖ **Change Attributes**

```js
const link = document.querySelector("a");
link.setAttribute("href", "https://google.com");
link.setAttribute("target", "_blank");
```

üí° **Alternative:**

```js
link.href = "https://google.com";
```

### ‚úÖ **Change Styles**

```js
const box = document.querySelector(".box");
box.style.backgroundColor = "blue";
box.style.fontSize = "20px";
```

---

## **üöÄ 3Ô∏è‚É£ Adding & Removing Elements**

You can dynamically add or remove elements in the DOM.

### ‚úÖ **Create and Append Elements**

```js
const newItem = document.createElement("li");
newItem.textContent = "New List Item";

const list = document.querySelector("ul");
list.appendChild(newItem); // Adds at the end
```

### ‚úÖ **Insert Before a Specific Element**

```js
const referenceItem = document.querySelector(".list-item");
list.insertBefore(newItem, referenceItem);
```

### ‚úÖ **Remove an Element**

```js
newItem.remove(); // Removes the newly added item
```

üí° **Older Method (for older browsers)**

```js
list.removeChild(newItem);
```

---

## **üöÄ 4Ô∏è‚É£ Event Handling**

JavaScript can handle user interactions using event listeners.

### ‚úÖ **Add an Event Listener**

```js
const button = document.querySelector("#clickMe");
button.addEventListener("click", function () {
  alert("Button Clicked!");
});
```

### ‚úÖ **Remove an Event Listener**

```js
function showAlert() {
  alert("You clicked!");
}
button.addEventListener("click", showAlert);

// Remove after 5 seconds
setTimeout(() => {
  button.removeEventListener("click", showAlert);
}, 5000);
```

### ‚úÖ **Event Object & Prevent Default**

```js
document.querySelector("form").addEventListener("submit", function (event) {
  event.preventDefault(); // Prevents page reload
  console.log("Form Submitted!");
});
```

---

## **üöÄ 5Ô∏è‚É£ Traversing the DOM**

Navigating between parent, child, and sibling elements.

### ‚úÖ **Parent Element**

```js
const child = document.querySelector(".child");
console.log(child.parentElement); // Gets the parent element
```

### ‚úÖ **Child Elements**

```js
const parent = document.querySelector(".parent");
console.log(parent.children); // HTMLCollection of child elements
console.log(parent.firstElementChild); // First child
console.log(parent.lastElementChild); // Last child
```

### ‚úÖ **Siblings**

```js
const item = document.querySelector(".list-item");
console.log(item.nextElementSibling); // Next sibling
console.log(item.previousElementSibling); // Previous sibling
```

---

## **üöÄ 6Ô∏è‚É£ ClassList ‚Äì Add, Remove, Toggle Classes**

```js
const box = document.querySelector(".box");

// Add a class
box.classList.add("highlight");

// Remove a class
box.classList.remove("highlight");

// Toggle a class
box.classList.toggle("hidden"); // Adds if not present, removes if present
```

---

**üî• Active Learning Tasks**
‚úÖ **Create a button that changes the background color of a div when clicked.**  
‚úÖ **Create a to-do list where you can add and remove items dynamically.**  
‚úÖ **Write a form that prevents submission and logs input values to the console.**  
‚úÖ **Implement an image slider using event listeners and `setAttribute`.**

---

**üî• Summary Table**
| Action | Method |
|--------|--------|
| **Select Element** | `getElementById`, `querySelector` |
| **Modify Content** | `.textContent`, `.innerHTML` |
| **Modify Styles** | `.style.property` |
| **Modify Attributes** | `.setAttribute()`, `.getAttribute()` |
| **Add Element** | `.createElement()`, `.appendChild()` |
| **Remove Element** | `.remove()`, `.removeChild()` |
| **Event Handling** | `.addEventListener()`, `.removeEventListener()` |

üöÄ **Master DOM Manipulation and build interactive web applications!**

# Understand event bubbling, capturing, delegation

**üî• Understanding Event Bubbling, Capturing, and Delegation in JavaScript üî•**

Events in JavaScript follow a specific propagation model that consists of **three phases**:

1. **Capturing Phase (Trickling Down)**
2. **Target Phase (Event Execution)**
3. **Bubbling Phase (Propagating Up)**

---

## **üöÄ 1Ô∏è‚É£ Event Bubbling (Bottom ‚Üí Up)**

- When an event occurs on a child element, it **bubbles up** through its ancestors.
- The event is first triggered on the **targeted element**, then moves **up** through parent elements until it reaches the `<html>` element.

### ‚úÖ **Example of Event Bubbling**

```js
document.getElementById("child").addEventListener("click", function () {
  alert("Child Clicked!");
});

document.getElementById("parent").addEventListener("click", function () {
  alert("Parent Clicked!");
});

document.getElementById("grandparent").addEventListener("click", function () {
  alert("Grandparent Clicked!");
});
```

### **üßê What Happens When You Click on "Child"?**

1. `Child Clicked!` (child event fires first)
2. `Parent Clicked!` (bubbles up to parent)
3. `Grandparent Clicked!` (bubbles up further)

üí° **Event bubbling is the default behavior.** If you want to stop it from bubbling up, use:

```js
event.stopPropagation();
```

---

## **üöÄ 2Ô∏è‚É£ Event Capturing (Top ‚Üí Down)**

- Also called **Event Trickling**.
- The event starts from the **top-most parent element** and goes **down to the target element**.

### ‚úÖ **Enable Event Capturing**

```js
document.getElementById("grandparent").addEventListener(
  "click",
  function () {
    alert("Grandparent Capturing Click!");
  },
  true // üëà Pass `true` to enable capturing mode
);
```

### **üßê What Happens When You Click on "Child"?**

1. `Grandparent Capturing Click!` (captures event first)
2. `Parent Clicked!`
3. `Child Clicked!`

üí° **By default, JavaScript uses event bubbling.** You must explicitly pass `true` to use event capturing.

---

## **üöÄ 3Ô∏è‚É£ Event Delegation (Efficient Event Handling)**

- Instead of adding event listeners to multiple elements, add a **single event listener to a common ancestor**.
- Useful for handling **dynamically created elements**.

### ‚úÖ **Example of Event Delegation**

```js
document.getElementById("list").addEventListener("click", function (event) {
  if (event.target.tagName === "LI") {
    alert("Item Clicked: " + event.target.textContent);
  }
});
```

```html
<ul id="list">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

### **üßê Why Use Event Delegation?**

‚úÖ Reduces memory usage (only one event listener for many elements).  
‚úÖ Works for dynamically added elements.

---

## **üî• Active Learning Tasks**

‚úÖ **Create a nested div structure and test event bubbling & capturing.**  
‚úÖ **Use `stopPropagation()` to prevent event bubbling.**  
‚úÖ **Implement event delegation on a to-do list (click to remove items).**

üöÄ **Mastering these concepts makes you a pro at event handling in JavaScript!** üöÄ

# <br/> <br/>

# Asynchronous JavaScript

# Understand callback functions

**üî• Understanding Callback Functions in JavaScript üî•**

A **callback function** is a **function passed as an argument** to another function. It allows asynchronous programming and **function execution control**.

---

## **üöÄ 1Ô∏è‚É£ Basic Callback Function Example**

```js
function greet(name, callback) {
  console.log("Hello, " + name);
  callback();
}

function sayGoodbye() {
  console.log("Goodbye!");
}

greet("Gagan", sayGoodbye);
```

### **üßê Output:**

```
Hello, Gagan
Goodbye!
```

üí° **`sayGoodbye` is passed as a callback and executed after `greet()` finishes.**

---

## **üöÄ 2Ô∏è‚É£ Callbacks in Asynchronous JavaScript**

Callbacks are commonly used in **setTimeout, setInterval, event listeners, and API calls**.

### ‚úÖ **Example: Using `setTimeout()`**

```js
console.log("Start");

setTimeout(function () {
  console.log("This runs after 2 seconds");
}, 2000);

console.log("End");
```

### **üßê Output (Async Behavior)**

```
Start
End
This runs after 2 seconds
```

üí° **Even though `setTimeout()` is executed first, it runs after 2 seconds due to async behavior.**

---

## **üöÄ 3Ô∏è‚É£ Callbacks in Array Methods**

Higher-order functions like `map()`, `filter()`, and `reduce()` use callback functions.

### ‚úÖ **Example: Using `map()`**

```js
const numbers = [1, 2, 3, 4];

const squaredNumbers = numbers.map(function (num) {
  return num * num;
});

console.log(squaredNumbers); // [1, 4, 9, 16]
```

üí° **`map()` calls the callback function for each array element.**

---

## **üöÄ 4Ô∏è‚É£ Callback Hell (Nested Callbacks Issue)**

- Callbacks can lead to **deep nesting** (difficult to read & maintain).
- Example of **Callback Hell**:

```js
setTimeout(() => {
  console.log("Task 1");
  setTimeout(() => {
    console.log("Task 2");
    setTimeout(() => {
      console.log("Task 3");
    }, 1000);
  }, 1000);
}, 1000);
```

üí° **Solution: Use Promises or Async/Await.**

---

## **üî• Active Learning Tasks**

‚úÖ **Create a function that takes a callback and calls it after a delay.**  
‚úÖ **Use a callback to filter out odd numbers from an array.**  
‚úÖ **Convert a callback-based function into a Promise.**

üöÄ **Master callbacks to better understand JavaScript async execution!** üöÄ

# Learn promises

**üî• Mastering Promises in JavaScript üî•**

A **Promise** in JavaScript is an object that represents the **eventual completion (or failure)** of an asynchronous operation. It allows you to write **cleaner and more manageable async code** compared to callbacks.

---

## **üöÄ 1Ô∏è‚É£ Understanding Promise States**

A Promise has **three states**:

1. **Pending** ‚Üí The initial state (waiting for the result).
2. **Fulfilled** ‚Üí The operation completed successfully (`resolve()` is called).
3. **Rejected** ‚Üí The operation failed (`reject()` is called).

---

## **üöÄ 2Ô∏è‚É£ Creating a Basic Promise**

A Promise is created using the `new Promise()` constructor.

### ‚úÖ **Example: Simple Promise**

```js
const myPromise = new Promise((resolve, reject) => {
  let success = true; // Change to false to see rejection
  setTimeout(() => {
    if (success) {
      resolve("‚úÖ Task Completed!");
    } else {
      reject("‚ùå Task Failed!");
    }
  }, 2000);
});

// Handling the Promise
myPromise
  .then((message) => console.log(message)) // Runs on resolve
  .catch((error) => console.log(error)) // Runs on reject
  .finally(() => console.log("üéØ Promise Execution Finished"));
```

### **üßê Output (if success = true)**

```
‚úÖ Task Completed!
üéØ Promise Execution Finished
```

### **üßê Output (if success = false)**

```
‚ùå Task Failed!
üéØ Promise Execution Finished
```

üí° **`.then()` runs when the promise is resolved.**  
üí° **`.catch()` runs when the promise is rejected.**  
üí° **`.finally()` always runs (whether resolved or rejected).**

---

## **üöÄ 3Ô∏è‚É£ Chaining Promises**

- **Each `.then()` returns a new Promise**, allowing us to chain multiple `.then()` calls.
- This prevents **callback hell** and makes async code more readable.

### ‚úÖ **Example: Chaining Multiple `.then()`**

```js
function fetchData() {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve("üì¶ Data Received"), 1000);
  });
}

fetchData()
  .then((data) => {
    console.log(data); // "üì¶ Data Received"
    return "üîÑ Processing Data...";
  })
  .then((message) => {
    console.log(message);
    return "‚úÖ Data Processed!";
  })
  .then(console.log) // Logs "‚úÖ Data Processed!"
  .catch(console.error)
  .finally(() => console.log("üéØ Task Completed"));
```

### **üßê Output**

```
üì¶ Data Received
üîÑ Processing Data...
‚úÖ Data Processed!
üéØ Task Completed
```

üí° **Each `.then()` receives the returned value from the previous `.then()`.**

---

## **üöÄ 4Ô∏è‚É£ Handling Multiple Promises**

Sometimes, you need to handle multiple Promises simultaneously. JavaScript provides methods like `Promise.all()`, `Promise.race()`, `Promise.allSettled()`, and `Promise.any()`.

### ‚úÖ **Using `Promise.all()`**

- Waits for **all** promises to complete.
- If **any** promise fails, the whole operation fails.

```js
const p1 = new Promise((resolve) =>
  setTimeout(() => resolve("ü•á Task 1"), 1000)
);
const p2 = new Promise((resolve) =>
  setTimeout(() => resolve("ü•à Task 2"), 2000)
);
const p3 = new Promise((resolve) =>
  setTimeout(() => resolve("ü•â Task 3"), 1500)
);

Promise.all([p1, p2, p3]).then(console.log);
// Output: ["ü•á Task 1", "ü•à Task 2", "ü•â Task 3"]
```

### ‚úÖ **Using `Promise.race()`**

- Returns the **first completed** promise (either resolved or rejected).

```js
Promise.race([p1, p2, p3]).then(console.log);
// Output: ü•á Task 1 (because it completes first)
```

### ‚úÖ **Using `Promise.allSettled()`**

- Waits for **all** promises to complete, whether resolved or rejected.

```js
const p4 = new Promise((_, reject) =>
  setTimeout(() => reject("‚ùå Failed Task"), 500)
);

Promise.allSettled([p1, p4]).then(console.log);
```

### ‚úÖ **Using `Promise.any()`**

- Returns the **first resolved** promise.
- Ignores rejected promises unless all fail.

```js
Promise.any([p4, p1]).then(console.log);
// Output: ü•á Task 1 (ignores the failed task)
```

---

## **üî• Active Learning Tasks**

‚úÖ **Create a Promise that resolves after 3 seconds and logs a message.**  
‚úÖ **Chain multiple `.then()` calls to process fetched data.**  
‚úÖ **Use `Promise.all()` to execute multiple API requests and log results.**

üöÄ **Mastering Promises is essential for handling async JavaScript efficiently!** üöÄ

# Master async/await and error handling

**üî• Mastering `async/await` and Error Handling in JavaScript üî•**

## **üöÄ What is `async/await`?**

- `async/await` is a modern way to handle **asynchronous operations** in JavaScript.
- It **replaces `.then()` and `.catch()`** for a more readable and synchronous-looking code.
- `async` functions **always return a Promise**.

---

## **üöÄ 1Ô∏è‚É£ Converting a Promise to `async/await`**

### ‚úÖ **Using Promises (Traditional Way)**

```js
function fetchData() {
  return new Promise((resolve) => {
    setTimeout(() => resolve("üì¶ Data Received"), 2000);
  });
}

fetchData()
  .then((data) => console.log(data))
  .catch((error) => console.log(error));
```

### ‚úÖ **Using `async/await` (Modern Approach)**

```js
async function getData() {
  let data = await fetchData(); // Wait until the promise resolves
  console.log(data);
}

getData();
```

üí° **`await` pauses execution until the Promise is resolved.**  
üí° **No need for `.then()`, making code cleaner and readable.**

---

## **üöÄ 2Ô∏è‚É£ Handling Errors in `async/await`**

If a promise **rejects**, we must handle the error using `try...catch`.

### ‚úÖ **Example: Handling Errors in `async/await`**

```js
async function fetchWithError() {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject("‚ùå Failed to fetch data!"), 2000);
  });
}

async function getData() {
  try {
    let data = await fetchWithError();
    console.log(data);
  } catch (error) {
    console.error("‚ö†Ô∏è Error:", error);
  } finally {
    console.log("üéØ Process completed");
  }
}

getData();
```

### **üßê Output**

```
‚ö†Ô∏è Error: ‚ùå Failed to fetch data!
üéØ Process completed
```

üí° **`try...catch` ensures graceful error handling without breaking execution.**  
üí° **`finally` runs whether the operation succeeds or fails.**

---

## **üöÄ 3Ô∏è‚É£ `async/await` with API Calls**

You can use `async/await` to fetch data from an API.

### ‚úÖ **Example: Fetching Data from an API**

```js
async function fetchUser() {
  try {
    let response = await fetch("https://jsonplaceholder.typicode.com/users/1");
    let user = await response.json();
    console.log(user);
  } catch (error) {
    console.error("‚ö†Ô∏è Fetch Error:", error);
  }
}

fetchUser();
```

üí° **No more `.then().catch()` chaining ‚Äì just clean and readable code!**  
üí° **`await` ensures we only proceed after fetching and converting to JSON.**

---

## **üöÄ 4Ô∏è‚É£ Running Multiple Async Calls Simultaneously**

Use `Promise.all()` with `async/await` to run multiple asynchronous operations **in parallel**.

### ‚úÖ **Example: Fetching Multiple Users at Once**

```js
async function fetchMultipleUsers() {
  try {
    let [user1, user2] = await Promise.all([
      fetch("https://jsonplaceholder.typicode.com/users/1").then((res) =>
        res.json()
      ),
      fetch("https://jsonplaceholder.typicode.com/users/2").then((res) =>
        res.json()
      ),
    ]);

    console.log("üë§ User 1:", user1);
    console.log("üë§ User 2:", user2);
  } catch (error) {
    console.error("‚ö†Ô∏è Error fetching users:", error);
  }
}

fetchMultipleUsers();
```

üí° **`Promise.all()` runs all API calls in parallel, improving performance.**

---

## **üî• Active Learning Tasks**

‚úÖ **Convert a `.then()`-based Promise to `async/await`.**  
‚úÖ **Use `async/await` to fetch API data and log the results.**  
‚úÖ **Handle errors gracefully using `try...catch`.**  
‚úÖ **Use `Promise.all()` with `async/await` to fetch multiple data sources in parallel.**

üöÄ **Mastering `async/await` is crucial for writing clean, efficient, and readable async JavaScript!** üöÄ

# Know how event loop, microtasks, and macrotasks work

**üî• Understanding Event Loop, Microtasks, and Macrotasks in JavaScript üî•**

## **üöÄ What is the Event Loop?**

The **Event Loop** is a mechanism in JavaScript that allows **asynchronous** code execution **without blocking** the main thread. It continuously checks the **Call Stack** and **Task Queue** to determine what should be executed next.

---

## **üöÄ JavaScript Execution Model**

1. **Call Stack (Synchronous Tasks)**

   - Executes functions in a **LIFO (Last In, First Out)** order.
   - Each function call is pushed onto the stack and popped off after execution.

2. **Web APIs (Async Operations like `setTimeout`, `fetch`)**

   - Handles asynchronous operations like **timers, HTTP requests, and event listeners**.

3. **Task Queues:**

   - **Microtask Queue** (Higher priority) ‚Üí `Promise.then()`, `MutationObserver`, `queueMicrotask()`
   - **Macrotask Queue** (Lower priority) ‚Üí `setTimeout()`, `setInterval()`, `setImmediate()`, I/O operations

4. **Event Loop**
   - Checks if the **Call Stack** is empty.
   - If empty, it **processes microtasks first** and then **moves to macrotasks**.

---

## **üöÄ 1Ô∏è‚É£ Understanding Microtasks vs. Macrotasks**

### **‚úÖ Microtasks (Higher Priority)**

- Run **immediately after the current function execution** and before the next rendering cycle.
- Examples:
  - **Promises (`.then()` and `.catch()`)**
  - `MutationObserver`
  - `queueMicrotask()`

### **‚úÖ Macrotasks (Lower Priority)**

- Scheduled after microtasks.
- Examples:
  - `setTimeout()`
  - `setInterval()`
  - `setImmediate()`
  - I/O operations (e.g., file read/write)

---

## **üöÄ 2Ô∏è‚É£ Code Example: Microtasks vs. Macrotasks**

```js
console.log("1Ô∏è‚É£ Start");

// Macrotask (setTimeout)
setTimeout(() => console.log("5Ô∏è‚É£ Macrotask - setTimeout"), 0);

// Microtask (Promise.then)
Promise.resolve().then(() => console.log("3Ô∏è‚É£ Microtask - Promise"));

// Normal synchronous task
console.log("2Ô∏è‚É£ Sync Task");
```

### **üßê Expected Output**

```
1Ô∏è‚É£ Start
2Ô∏è‚É£ Sync Task
3Ô∏è‚É£ Microtask - Promise
5Ô∏è‚É£ Macrotask - setTimeout
```

‚úÖ **Microtasks execute before macrotasks**, even if both are scheduled at the same time.

---

## **üöÄ 3Ô∏è‚É£ Event Loop in Action**

### ‚úÖ **Example: Multiple Microtasks & Macrotasks**

```js
console.log("1Ô∏è‚É£ Start");

// Macrotask
setTimeout(() => console.log("6Ô∏è‚É£ Macrotask - setTimeout"), 0);

// Microtask 1
Promise.resolve().then(() => {
  console.log("3Ô∏è‚É£ Microtask 1 - Promise");

  // Microtask inside Microtask
  Promise.resolve().then(() => console.log("4Ô∏è‚É£ Microtask 2 - Nested Promise"));
});

// Sync Task
console.log("2Ô∏è‚É£ Sync Task");

// Macrotask
setTimeout(() => console.log("7Ô∏è‚É£ Macrotask - setTimeout 2"), 0);
```

### **üßê Expected Output**

```
1Ô∏è‚É£ Start
2Ô∏è‚É£ Sync Task
3Ô∏è‚É£ Microtask 1 - Promise
4Ô∏è‚É£ Microtask 2 - Nested Promise
6Ô∏è‚É£ Macrotask - setTimeout
7Ô∏è‚É£ Macrotask - setTimeout 2
```

‚úÖ **Microtasks (`Promise.then()`) always execute before Macrotasks (`setTimeout()`).**  
‚úÖ **Nested Microtasks are executed before moving to Macrotasks.**

---

## **üöÄ 4Ô∏è‚É£ Visualizing the Event Loop**

```plaintext
1. Execute synchronous code (Call Stack tasks)
2. Process all Microtasks (Promise.then, queueMicrotask)
3. Render UI updates (if needed)
4. Process one Macrotask (setTimeout, I/O)
5. Repeat from step 2
```

### ‚úÖ **Event Loop Order**

```
1Ô∏è‚É£ Execute synchronous tasks in Call Stack
2Ô∏è‚É£ Process Microtasks
3Ô∏è‚É£ Process Macrotasks (only after all Microtasks are cleared)
4Ô∏è‚É£ Repeat
```

---

## **üî• Active Learning Tasks**

‚úÖ **Run an example where a `setTimeout()` and a `Promise.then()` are scheduled and observe the order.**  
‚úÖ **Modify a nested microtask example and predict the output.**  
‚úÖ **Use `queueMicrotask()` to schedule a microtask manually.**

üöÄ **Understanding the Event Loop is key to mastering asynchronous JavaScript!** üöÄ

#
